# 非经典计算第二次作业

## 1 写出阿克曼函数A（3，4）的值及计算过程，并请叙述，阿克曼函数为什么是非原始递归函数？

### 阿克曼函数 A(3, 4) 的值与计算过程

阿克曼函数如下：

$A(m, n) = \begin{cases}
    n + 1 ; \quad m = 0 \\
    A(m - 1, 1) ; \quad m > 0 , n = 0 \\
    A(m - 1, A(m, n - 1)) ; \quad m > 0 , n > 0 \\
\end{cases}
$

根据以下两个规律：

$\begin{aligned}
A(1, n) =& A(0, A(1, n - 1)) \\
=& A(0, A(0, A(1, n - 2))) \\
=& A(0, A(0, A(0, \ldots A(1, 0)))) \\
=& A(0, A(0, A(0, \ldots A(0, 1)))) \\
=& n + 2
\end{aligned}$

$\begin{aligned}
A(2, n) =& A(1, A(2, n - 1)) \\
 =& A(1, A(1, A(2, n - 2))) \\
 =& A(1, A(1, A(1, \ldots A(2, 0)))) \\
 =& 2(n + 2) - 1 \\
 =& 2n + 3  \\
\end{aligned}$

由以上两个规律可得：

$\begin{aligned}
A(3, 4) =& A(2, A(3, 3)) \\
=& A(2, A(2, A(3, 2))) \\
=& A(2, A(2, A(2, A(3, 1)))) \\
=& A(2, A(2, A(2, A(2, A(3, 0))))) \\
=& A(2, A(2, A(2, A(2, A(2, 1))))) \\
=& A(2, A(2, A(2, A(2, 5))))  \\
=& A(2, A(2, A(2, 13))) \\
=& A(2, A(2, 29)) \\
=& A(2, 61) \\
=& 125
\end{aligned}$

### 阿克曼函数为什么不是原始递归函数？

阿克曼函数是可计算的，但其值的增长速度大于任何一个原始递归函数即对于任何一个原始递归函数都可找到一个数 $\alpha$ 使得 $f(x) < g(\alpha, x)$

因此，阿克曼函数不是原始递归函数

## 2 什么是一般可递归函数？什么是λ转换演算？什么是Post递归函数？（任选其一回答）

一般可递归函数：由初始函数出发，经过有限次使用代入、原始递归式和 $\mu$ 算子而做成的有定义的函数。此处的 $\mu$ 算子就是造逆函数的算子或求根算子

## 3 如何理解「经典计算无法解决」的问题，可以举例说明

定义一个集合P，集合P包含了所有一类经典计算机的最优算法能够在输入规模为N的多项式时间内解决的问题，如排序，快速傅里叶变换，求解两地最短路径问题等。P问题在理论分析中被认为是「容易的问题」。

还可以定义一个集合NP，集合NP包含了所有可以在多项式时间内验证结果的问题。而直到今天「P = NP ？」仍然没有定论。

量子计算机具有天然的随机性，因此量子计算机的问题主要依靠随机算法，而量子计算机中对应于经典计算机BPP定义的集合称为BQP。BPP内部的问题可以被认为是经典计算机可以高效解决的问题，而BQP集合内的问题，是量子计算机可以高效解决的问题