# 第四章 指令系统

## 4.1 指令格式

### 4.1.1 操作码与地址码的基本概念

含义：一条指令就是机器语言中的一个语句，用来表示一串有意义的二进制代码。

结构：一条指令通常会包括两个字段：**操作码**字段和**地址码**字段。

* 操作码：指出这条指令的功能，也就是这条指令是「干什么」的
* 地址码：有些操作码是需要指明操作对象的，这时就需要地址码来给出这些对象的地址，也就是「对谁进行操作」

以上的结构是一个抽象的概念，并没有指明指令内部中操作码和地址码具体会分配到几个二进制位，下面给出一个具体的例子：
> 比如我们给出一个四地址指令：
> | OP | $A_1$ | $A_2$ | $A_3$ (结果) | $A_4$ (下址) |
> 该指令执行的操作是：将A1地址的内容与A2地址的内容进行一个OP操作，将结果存在A3给出的地址里，然后根据A4给出的地址去获取下一个指令的地址
> 含义：($A_1$) OP ($A_2$) $\rightarrow$ $A_3$, $A_4$ = 下一个执行指令的地址
> 加了括号表明是地址指向的内容，而不是地址间进行操作或运算
> 假设指令字长为32位，操作码占8位，4个地址码分别各占6位，同时设存储字长为32位即4B：
> | 00000000 | 000001 | 000010 | 000011 | 000100 |
> * $A_i$ 可以直接表示 $2^6$ 个不同的位置
> * 一条指令的执行：**取指令**访存1次，**取两个操作数**访存2次，**将结果存回**访存1次，共4次。

如果我们将指令和数据的排列方式改变一下，指令放在一块儿，数据放在一块儿，这样我们就可以不用在指令中给出下一个指令的地址，而是设计一个程序计数器PC，每次取出当前指令后，自动到下一个地址去取指令就可以了。

根据一条指令中有几个操作数地址，可以将该指令称为**几操作数指令**或**几地址指令**。

各种不同操作数的指令格式如下图.

![不同操作数的指令格式](images/2023-01-08-17-56-43.png)

**三地址指令**：

| OP | $A_1$ | $A_2$ | $A_3$ (结果) |

含义：($A_1$) OP ($A_2$) $\rightarrow$ $A_3$

**二地址指令**：

| OP | $A_1$ (目的操作数) | $A_2$ (源操作数) |

二地址指令常被称为**双操作数指令**

含义：($A_1$) OP ($A_2$) $\rightarrow$ $A_1$

> 在二地址指令中，根据操作数的物理位置，又可以归结为三种不同的类型：
> * 存储器-存储器(SS)型：访问内存的指令格式，这种指令操作时都是涉及**内存单元**，即参与操作的数都放在内存单元中
> * 寄存器-寄存器(RR)型：访问寄存器的指令格式，这种指令操作时都是涉及**寄存器**，执行过程中需要多个通用寄存器或个别专用寄存器
> * 寄存器-存储器(RS)型：执行这类指令时，既要访问内存单元，又要访问寄存器



**一地址指令**：

| OP | $A_1$ |

含义：

1. OP($A_1$) $\rightarrow$ $A_1$ ，如加1、减一、取反、求补等
2. (ACC) OP ($A_1$) $\rightarrow$ ACC, 隐含约定的目的地址

**零地址指令**

| OP |

零地址指令中只有操作码，没有地址码。

含义：

1. 不需要操作数，如空操作、停机、关中断等操作
2. 堆栈计算机，两个操作数隐含放在栈顶和次栈顶，结果压回栈顶

### 4.1.2 指令字长度

1.什么是指令字

表示一条指令的机器字，就称为指令字，通常简称指令。

2.什么是指令字长度

一个指令字中二进制位的个数，称为指令字长度。

以机器字长度为衡量单位，可以有如下的指令分类.

* 单字长指令：指令字长度等于机器字长度的指令
* 半字长指令：指令字长度等于半个机器字长度的指令
* 双字长指令：指令字长度等于两个机器字长度的指令

3.什么是机器字长

计算机可以直接处理的二进制数据的位数

4.定长与变长

定长指令字结构：在减少地址码个数的过程中，整个指令的字长没有发生变化。如四地址变化到三地址指令

变长指令字结构：在减少地址码个数的过程中，指令的字长发生了改变。如一地址变化到零地址指令

定长操作码：n位操作码对应会有 $2^n$ 种不同的操作码，就指令功能而言，就可以有 $2^n$ 条指令

扩展操作码：操作码的长度是可变的。这里的扩展操作码只是变长操作码中的一种策略

5.扩展操作码(需要掌握)

假设某等长指令字结构机器的指令长度为16位，由4位操作码字段和3个4位地址码字段组成

| 操作码(4bit) | 地址码(4bit) | 地址码(4bit) | 地址码(4bit) |
| :---: | :---: | :---: | :---: |
| OP | $A_1$ | $A_2$ | $A_3$ |

![扩展操作码实例](images/2023-01-08-18-35-16.png)

三地址指令为15条：编码空间为「0000 ~ 1110」，剩下1111留给下一层扩展

> 解释：高四位表示操作码，但由于只有15条，因此「1111」不属于三地址指令中的操作码，剩下的低12位表示地址码

二地址指令为14条：由上一层留下了「1111」作为扩展，因此，编码空间为「1111 0000 ~ 1111 1101」

> 解释：高四位为「1111」时，再加上 $A_1$ 域的14种组合就代表了不同的二地址指令，剩下的低8位正常表示地址码

一地址指令为31条：编码空间有「1111 1110 0000 ~ 1111 1110 1111」和 「1111 1111 0000 ~ 1111 1111 1110」

> 解释：上一层留下两个前缀作为扩展分别是 「1111 1110」和 「1111 1111」，因此只有 $A_3$ 域表示地址码

零地址指令为16条：编码空间为 「1111 1111 1111 0000 ~ 1111 1111 1111 1111」

> 零地址没有地址码字段，上一层只留下了「1111 1111 1111」这个前缀，搭配低4位构成不同的指令

在设计扩展操作码指令格式时，需要注意以下两点.
* 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分相同。例如二地址指令的高四位不能与三地址指令操作码字段中任何组合相同
* 各指令的操作码不能重复
* 一般情况下，会给使用频率较高的指令，分配较短的指令码
* 以上都可以参考哈夫曼编码

## 4.2 寻址方式

### 4.2.1 指令寻址

1. 什么是指令寻址
   定位下一条将要执行指令的地址。一般情况下都是由程序计数器PC给出下一条执行指令的地址

2. 指令寻址方式
   * 顺序寻址方式：按顺序从程序计数器PC中取出指令，也就是取完第一条之后再接着取第二条、第三条、...
   * 跳跃寻址方式：由转移指令给出下一条指令的地址，而不是像顺序寻址一样按部就班地按地址在内存中的顺序



### 4.2.2 数据寻址

## 4.3 CISC 和 RISC

